//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;
using System;
using System.Runtime.InteropServices;
using System.Threading;

public partial class HDevelopExport_Location_3_0
{
  public void HDevelopStop()
  {
  }

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image.
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_MinWidth=new HTuple(), hv_MaxWidth=new HTuple();
    HTuple hv_MinHeight=new HTuple(), hv_MaxHeight=new HTuple();
    HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
    HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

    // Initialize local and output iconic variables 

    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"buffer","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
    }

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message.
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {


    // Local control variables 

    HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
    HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
    HTuple hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
    HTuple hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1=new HTuple();
    HTuple hv_C1=new HTuple(), hv_FactorRow=new HTuple(), hv_FactorColumn=new HTuple();
    HTuple hv_Width=new HTuple(), hv_Index=new HTuple(), hv_Ascent=new HTuple();
    HTuple hv_Descent=new HTuple(), hv_W=new HTuple(), hv_H=new HTuple();
    HTuple hv_FrameHeight=new HTuple(), hv_FrameWidth=new HTuple();
    HTuple hv_R2=new HTuple(), hv_C2=new HTuple(), hv_DrawMode=new HTuple();
    HTuple hv_Exception=new HTuple(), hv_CurrentColor=new HTuple();

    HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
    HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
    HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
    HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

    // Initialize local and output iconic variables 

    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically
    //   for each new textline.
    //Box: If set to 'true', the text is written within a white box.
    //
    //prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part, 
        out hv_Column2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //default settings
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    //
    hv_String_COPY_INP_TMP = (((""+hv_String_COPY_INP_TMP)+"")).TupleSplit("\n");
    //
    //Estimate extentions of text depending on font size.
    HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
        out hv_MaxWidth, out hv_MaxHeight);
    if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
    {
      hv_R1 = hv_Row_COPY_INP_TMP.Clone();
      hv_C1 = hv_Column_COPY_INP_TMP.Clone();
    }
    else
    {
      //transform image to window coordinates
      hv_FactorRow = (1.0*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
      hv_FactorColumn = (1.0*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
      hv_R1 = ((hv_Row_COPY_INP_TMP-hv_Row1Part)+0.5)*hv_FactorRow;
      hv_C1 = ((hv_Column_COPY_INP_TMP-hv_Column1Part)+0.5)*hv_FactorColumn;
    }
    //
    //display text box depending on text size
    if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
    {
      //calculate box extents
      hv_String_COPY_INP_TMP = (" "+hv_String_COPY_INP_TMP)+" ";
      hv_Width = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
            hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
        hv_Width = hv_Width.TupleConcat(hv_W);
      }
      hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ));
      hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
      hv_R2 = hv_R1+hv_FrameHeight;
      hv_C2 = hv_C1+hv_FrameWidth;
      //display rectangles
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      HOperatorSet.SetDraw(hv_WindowHandle, "fill");
      HOperatorSet.SetColor(hv_WindowHandle, "light gray");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+3, hv_C1+3, hv_R2+3, hv_C2+3);
      HOperatorSet.SetColor(hv_WindowHandle, "white");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
      HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
    }
    else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
    {
      hv_Exception = "Wrong value of control parameter Box";
      throw new HalconException(hv_Exception);
    }
    //Write text.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
          )));
      if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
          "auto")))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
      }
      else
      {
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      }
      hv_Row_COPY_INP_TMP = hv_R1+(hv_MaxHeight*hv_Index);
      HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
      HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index));
    }
    //reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, 
        hv_Column2Part);

    return;
  }

  // Chapter: File
  // Short Description: Parse a filename into directory, base filename, and extension
  public void parse_filename (HTuple hv_FileName, out HTuple hv_BaseName, out HTuple hv_Extension, 
      out HTuple hv_Directory)
  {


    // Local control variables 

    HTuple hv_DirectoryTmp;

    // Initialize local and output iconic variables 

    //This procedure gets a filename (with full path) as input
    //and returns the directory path, the base filename and the extension
    //in three different strings.
    //
    //In the output path the path separators will be replaced
    //by '/' in all cases.
    //
    //The procedure shows the possibilities of regular expressions in HALCON.
    //
    //Input parameters:
    //FileName: The input filename
    //
    //Output parameters:
    //BaseName: The filename without directory description and file extension
    //Extension: The file extension
    //Directory: The directory path
    //
    //Example:
    //basename('C:/images/part_01.png',...) returns
    //BaseName = 'part_01'
    //Extension = 'png'
    //Directory = 'C:\\images\\' (on Windows systems)
    //
    //Explanation of the regular expressions:
    //
    //'([^\\\\/]*?)(?:\\.[^.]*)?$':
    //To start at the end, the '$' matches the end of the string,
    //so it is best to read the expression from right to left.
    //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
    //That means, that this part is matched, but not captured
    //in contrast to the first bracketed group ([^\\\\/], see below.)
    //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
    //So (?:\\.[^.]*)? matches the file extension, if any.
    //The '?' at the end assures, that even if no extension exists,
    //a correct match is returned.
    //The first part in brackets ([^\\\\/]*?) is a capture group,
    //which means, that if a match is found, only the part in
    //brackets is returned as a result.
    //Because both HDevelop strings and regular expressions need a '\\'
    //to describe a backslash, inside regular expressions within HDevelop
    //a backslash has to be written as '\\\\'.
    //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
    //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
    //where the '?' after the '*' switches the greediness off,
    //that means, that the shortest possible match is returned.
    //This option is necessary to cut off the extension
    //but only if (?:\\.[^.]*)? is able to match one.
    //To summarize, the regular expression matches that part of
    //the input string, that follows after the last '/' or '\\' and
    //cuts off the extension (if any) after the last '.'.
    //
    //'\\.([^.]*)$':
    //This matches everything after the last '.' of the input string.
    //Because ([^.]) is a capturing group,
    //only the part after the dot is returned.
    //
    //'.*[\\\\/]':
    //This matches the longest substring with a '/' or a '\\' at the end.
    //
    HOperatorSet.TupleRegexpMatch(hv_FileName, "([^\\\\/]*?)(?:\\.[^.]*)?$", out hv_BaseName);
    HOperatorSet.TupleRegexpMatch(hv_FileName, "\\.([^.]*)$", out hv_Extension);
    HOperatorSet.TupleRegexpMatch(hv_FileName, ".*[\\\\/]", out hv_DirectoryTmp);
    //
    //Finally all found backslashes ('\\') are converted
    //to a slash to get consistent paths
    HOperatorSet.TupleRegexpReplace(hv_DirectoryTmp, (new HTuple("\\\\")).TupleConcat(
        "replace_all"), "/", out hv_Directory);

    return;
  }

  // Local procedures 
  public void parse_coordinate_silver (HObject ho_Image, HTuple hv_owindowHandle, 
      HTuple hv_Blk_and_Wht, out HTuple hv_Delta_x, out HTuple hv_Delta_y, out HTuple hv_angle_out, 
      out HTuple hv_x_c, out HTuple hv_y_c,out int result)
  {

        result = 1;

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
    long SP_O = 0;
        for (int i = 0; i < 20; i++)
        {
            HOperatorSet.GenEmptyObj(out OTemp[i]);
        }
    // Local iconic variables 

    HObject ho_image_original=null, ho_RectangleROI=null;
    HObject ho_ImageReducedS=null, ho_RegionS=null, ho_ConnectedRegionsS=null;
    HObject ho_SelectedRegionsSAll_0=null, ho_SelectedRegionsSAll=null;
    HObject ho_SelectedRegionsS=null, ho_ImageRotateS=null;
    HObject ho_ImageReducedS2=null, ho_RegionS2=null, ho_RegionFillUp=null;
    HObject ho_RegionLinesFitBottomRow=null, ho_RegionLinesFitRightCol=null;
    HObject ho_workingRegion=null, ho_SelectedRegionsSBody=null;
    HObject ho_Rectangle_body=null, ho_Circle_Rotated=null;
    HObject ho_Circle_cen=null, ho_Circle=null, ho_FitBottomRowRotated=null;
    HObject ho_FitRightColRotated=null;


    // Local control variables 

    HTuple hv_width_image=new HTuple(), hv_height_image=new HTuple();
    HTuple hv_m_target_row=new HTuple(), hv_m_target_column=new HTuple();
    HTuple hv_m_row_image_center=new HTuple(), hv_m_col_image_center=new HTuple();
    HTuple hv_m_scale_pixel_to_mm=new HTuple(), hv_m_degreerotate_between_axes=new HTuple();
    HTuple hv_height_body=new HTuple(), hv_width_body=new HTuple();
    HTuple hv_width_total=new HTuple(), hv_m_offset_catching_row=new HTuple();
    HTuple hv_m_offset_catching_col=new HTuple(), hv_m_possiblearea_2ndrow1=new HTuple();
    HTuple hv_m_possiblearea_2ndrow2=new HTuple(), hv_m_possiblearea_2ndcol1=new HTuple();
    HTuple hv_m_possiblearea_2ndcol2=new HTuple(), hv_m_maxgray_find_contour=new HTuple();
    HTuple hv_RowE1=new HTuple(), hv_ColE1=new HTuple(), hv_RowE2=new HTuple();
    HTuple hv_ColE2=new HTuple(), hv_Row3=new HTuple(), hv_Column3=new HTuple();
    HTuple hv_Phi=new HTuple(), hv_Length1=new HTuple(), hv_Length2=new HTuple();
    HTuple hv_Area=new HTuple(), hv_Row=new HTuple(), hv_Column=new HTuple();
    HTuple hv_degreeBattery=new HTuple(), hv_pi=new HTuple();
    HTuple hv_bResultTabOri=new HTuple(), hv_Column2=new HTuple();
    HTuple hv_Row2=new HTuple(), hv_Row1RectOut=new HTuple();
    HTuple hv_Col1RectOut=new HTuple(), hv_Row2RectOut=new HTuple();
    HTuple hv_Col2RectOut=new HTuple(), hv_Row11LinesFit=new HTuple();
    HTuple hv_Column11LinesFit=new HTuple(), hv_Row21LinesFit=new HTuple();
    HTuple hv_Column21LinesFit=new HTuple(), hv_Row11LineFitRight=new HTuple();
    HTuple hv_Column11LineFitRight=new HTuple(), hv_Row21LineFitRight=new HTuple();
    HTuple hv_Column21LineFitRight=new HTuple(), hv_Row1SRectInn=new HTuple();
    HTuple hv_Col1SRectInn=new HTuple(), hv_Row2SRectInn=new HTuple();
    HTuple hv_Col2SRectInn=new HTuple(), hv_Row2Using=new HTuple();
    HTuple hv_Col2Using=new HTuple(), hv_Row11=new HTuple();
    HTuple hv_Column11=new HTuple(), hv_Row21=new HTuple();
    HTuple hv_Column21=new HTuple(), hv_x_centerRaw=new HTuple();
    HTuple hv_y_centerRaw=new HTuple(), hv_x_c1=new HTuple();
    HTuple hv_y_c1=new HTuple(), hv_dx=new HTuple(), hv_dy=new HTuple();
    HTuple hv_ds=new HTuple(), hv_r=new HTuple(), hv_Theta=new HTuple();
    HTuple hv_Alpha=new HTuple(), hv_dx2=new HTuple(), hv_dy2=new HTuple();
    HTuple hv_Sgn_x=new HTuple(), hv_Sgn_y=new HTuple(), hv_Exception;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_image_original);
    HOperatorSet.GenEmptyObj(out ho_RectangleROI);
    HOperatorSet.GenEmptyObj(out ho_ImageReducedS);
    HOperatorSet.GenEmptyObj(out ho_RegionS);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegionsS);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsSAll_0);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsSAll);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsS);
    HOperatorSet.GenEmptyObj(out ho_ImageRotateS);
    HOperatorSet.GenEmptyObj(out ho_ImageReducedS2);
    HOperatorSet.GenEmptyObj(out ho_RegionS2);
    HOperatorSet.GenEmptyObj(out ho_RegionFillUp);
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFitBottomRow);
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFitRightCol);
    HOperatorSet.GenEmptyObj(out ho_workingRegion);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsSBody);
    HOperatorSet.GenEmptyObj(out ho_Rectangle_body);
    HOperatorSet.GenEmptyObj(out ho_Circle_Rotated);
    HOperatorSet.GenEmptyObj(out ho_Circle_cen);
    HOperatorSet.GenEmptyObj(out ho_Circle);
    HOperatorSet.GenEmptyObj(out ho_FitBottomRowRotated);
    HOperatorSet.GenEmptyObj(out ho_FitRightColRotated);

    hv_Delta_x = new HTuple();
    hv_Delta_y = new HTuple();
    hv_angle_out = new HTuple();
    hv_x_c = new HTuple();
    hv_y_c = new HTuple();
    try
    {
      try
      {
        HOperatorSet.GetImageSize(ho_Image, out hv_width_image, out hv_height_image);
        //=============1）设备相关参数/相机/机械手
        //机械手的示教点，视野中心
        hv_m_target_row = ATL_MC.Vision.Vision.batteryCFG.dMoveInTargetX;
        hv_m_target_column = ATL_MC.Vision.Vision.batteryCFG.dMoveInTargetY;

        //image center
        hv_m_row_image_center = hv_height_image/2;
        hv_m_col_image_center = hv_width_image/2;

        //像素实际物理尺寸比例mm
        hv_m_scale_pixel_to_mm = ATL_MC.Vision.Vision.cc.CameraScale_MoveIn;

        //坐标系角度旋转,机械手坐标系和相机坐标系
        hv_m_degreerotate_between_axes = 0;

        //=============2）电芯型号相关
        //电池本体的长宽
        //*height_body:=93.0/scale
        hv_height_body = ATL_MC.Vision.Vision.batteryCFG.dHeight / hv_m_scale_pixel_to_mm;
        //*width_body:=39.0/scale
        hv_width_body = ATL_MC.Vision.Vision.batteryCFG.dWidth/ hv_m_scale_pixel_to_mm;
        hv_width_total = hv_width_body.Clone();

        //机械手抓料点和计算的出的抓取点的偏移。
        hv_m_offset_catching_row = 0.0/hv_m_scale_pixel_to_mm;
        hv_m_offset_catching_col = 0.0/hv_m_scale_pixel_to_mm;


        //=============3）算法相关（可供外部修改/外部不可修改）
        HOperatorSet.GetImageSize(ho_Image, out hv_width_image, out hv_height_image);
        //电池可能出现的能够进行处理的区域,剔除边界区域
        //m_possiblearea_tapeoffset := 2594/2-(width_body*0.5+15/m_scale_pixel_to_mm)
        //m_possiblearea_tapeoffset := 200

        //剔除边界区域可能也剔除tab区域，极耳朝上
        hv_m_possiblearea_2ndrow1 = ATL_MC.Vision.Vision.cc.lLocationParametersRow1;
        hv_m_possiblearea_2ndrow2 = ATL_MC.Vision.Vision.cc.lLocationParametersRow2;
        //m_possiblearea_2ndcol1 := 180+m_possiblearea_tapeoffset
        hv_m_possiblearea_2ndcol1 = ATL_MC.Vision.Vision.cc.lLocationParametersCol1;
        hv_m_possiblearea_2ndcol2 = ATL_MC.Vision.Vision.cc.lLocationParametersCol2;

        //用于查找电池本体轮廓的:R/G/B/H/L/S ==1/2/3/4/5/6

        hv_m_maxgray_find_contour = 80;


        //=============4）输出结果的初始化
        //输出变量初始化
        hv_angle_out = 0;
        hv_Delta_x = 0;
        hv_Delta_y = 0;
        hv_x_c = 0;
        hv_y_c = 0;


        //=============5）算法实现主体和异常处理
        //get the bright strip at the bottom
        //decompose3 (Image, ImageR, image_original, ImageB)
        //trans_from_rgb (ImageR, image_original, ImageB, ImageH, image_original, ImageV, 'hsv')
        ho_image_original.Dispose();
        HOperatorSet.CopyImage(ho_Image, out ho_image_original);


        //1)首先找到电芯的旋转角度（非精确）
        HOperatorSet.SetDraw(hv_owindowHandle, "margin");
        HOperatorSet.SetColor(hv_owindowHandle, "red");
        ho_RectangleROI.Dispose();
        HOperatorSet.GenRectangle1(out ho_RectangleROI, hv_m_possiblearea_2ndrow1, 
            hv_m_possiblearea_2ndcol1, hv_m_possiblearea_2ndrow2, hv_m_possiblearea_2ndcol2);
        //gen_rectangle1 (RectangleROI, 300, 200, 1500, 2000)

        //检测区域（非全视野）
        ho_ImageReducedS.Dispose();
        HOperatorSet.ReduceDomain(ho_image_original, ho_RectangleROI, out ho_ImageReducedS
            );

        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(1))) != 0)
        {
          //threshold (ImageReducedS, RegionS, 220, m_maxgray_find_contour)
          ho_RegionS.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS, out ho_RegionS, 220, 255);
        }
        else
        {
          //threshold (ImageReducedS, RegionS, 0, m_maxgray_find_contour)
          ho_RegionS.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS, out ho_RegionS, 0, 80);
        }

        OTemp[SP_O] = ho_RegionS.CopyObj(1,-1);
        SP_O++;
        ho_RegionS.Dispose();
        HOperatorSet.FillUp(OTemp[SP_O-1], out ho_RegionS);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.Connection(ho_RegionS, out ho_ConnectedRegionsS);
        ho_SelectedRegionsSAll_0.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegionsS, out ho_SelectedRegionsSAll_0, 
            ((new HTuple("area")).TupleConcat("height")).TupleConcat("width"), "and", 
            ((((((hv_height_body*hv_width_total)*2)/4)).TupleConcat(hv_height_body/2))).TupleConcat(
            hv_width_total/2), ((((hv_height_body*hv_width_image)).TupleConcat(hv_height_body*2.5))).TupleConcat(
            hv_width_image));
        //不能处于边缘，否则找到的电芯可能不完整导致定位不准确
        //不能处于右边缘，剔除已经靠近右边缘的疑似电池区域,缺点是电池会向后堆叠
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SelectShape(ho_SelectedRegionsSAll_0, out ho_SelectedRegionsSAll, 
            "column2", "and", hv_m_possiblearea_2ndcol1+1, hv_m_possiblearea_2ndcol2-1);

        //获取可能区域中的最右区域
        OTemp[SP_O] = ho_SelectedRegionsSAll.CopyObj(1,-1);
        SP_O++;
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SortRegion(OTemp[SP_O-1], out ho_SelectedRegionsSAll, "lower_right", 
            "false", "column");
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        ho_SelectedRegionsS.Dispose();
        HOperatorSet.SelectObj(ho_SelectedRegionsSAll, out ho_SelectedRegionsS, 1);

        //电池不能处于视野的边界（可能电池区域不完整）,增加告警
        //如果已经处于右边界，需要增加告警，否则电池可能被推跌落!!!
        HOperatorSet.SmallestRectangle1(ho_SelectedRegionsS, out hv_RowE1, out hv_ColE1, 
            out hv_RowE2, out hv_ColE2);
        HOperatorSet.SmallestRectangle2(ho_SelectedRegionsS, out hv_Row3, out hv_Column3, 
            out hv_Phi, out hv_Length1, out hv_Length2);
        HOperatorSet.AreaCenter(ho_SelectedRegionsS, out hv_Area, out hv_Row, out hv_Column);
        if ((int)((new HTuple((new HTuple((new HTuple(hv_RowE1.TupleLessEqual(hv_m_possiblearea_2ndrow1+1))).TupleOr(
            new HTuple(hv_ColE1.TupleLessEqual(hv_m_possiblearea_2ndcol1+1))))).TupleOr(
            new HTuple(hv_RowE2.TupleGreaterEqual(hv_m_possiblearea_2ndrow2-1))))).TupleOr(
            new HTuple(hv_ColE2.TupleGreaterEqual(hv_m_possiblearea_2ndcol2-1)))) != 0)
        {

          if ((int)((new HTuple(hv_Area.TupleGreater((1.2*hv_height_body)*hv_width_total))).TupleAnd(
              (new HTuple(hv_ColE2.TupleLess(hv_m_possiblearea_2ndcol2-1))).TupleAnd(
              new HTuple(hv_RowE2.TupleLess(hv_m_possiblearea_2ndrow2-1))))) != 0)
          {
            //*********电池交叠在一起处理功能
            Battery_Overlap_Insp(ho_Image, ho_SelectedRegionsS, hv_height_body, hv_width_body, 
                out hv_Phi);
          }
          else
          {
            //by JT 20181207
            disp_message(hv_owindowHandle, "No Battery in the field of view", "window", 
                100, 120, "red", "true");

            ho_image_original.Dispose();
            ho_RectangleROI.Dispose();
            ho_ImageReducedS.Dispose();
            ho_RegionS.Dispose();
            ho_ConnectedRegionsS.Dispose();
            ho_SelectedRegionsSAll_0.Dispose();
            ho_SelectedRegionsSAll.Dispose();
            ho_SelectedRegionsS.Dispose();
            ho_ImageRotateS.Dispose();
            ho_ImageReducedS2.Dispose();
            ho_RegionS2.Dispose();
            ho_RegionFillUp.Dispose();
            ho_RegionLinesFitBottomRow.Dispose();
            ho_RegionLinesFitRightCol.Dispose();
            ho_workingRegion.Dispose();
            ho_SelectedRegionsSBody.Dispose();
            ho_Rectangle_body.Dispose();
            ho_Circle_Rotated.Dispose();
            ho_Circle_cen.Dispose();
            ho_Circle.Dispose();
            ho_FitBottomRowRotated.Dispose();
            ho_FitRightColRotated.Dispose();
                        for (int i = 0; i < 20; i++)
                        {
                            OTemp[i].Dispose();
                        }
                        return;
          }



        }

        //*************************
        if ((int)(new HTuple(hv_Area.TupleGreater((1.2*hv_height_body)*hv_width_total))) != 0)
        {
          //*********电池交叠在一起处理功能
          Battery_Overlap_Insp(ho_Image, ho_SelectedRegionsS, hv_height_body, hv_width_body, 
              out hv_Phi);
        }
        else
        {
        }


        //需要改进，只是矩形的话没有方向性，需要增加极耳的朝向因子
        hv_degreeBattery = hv_Phi*57.3;
        hv_pi = 3.1416;
        if ((int)(new HTuple(hv_height_body.TupleGreater(hv_width_body))) != 0)
        {
          if ((int)(new HTuple(hv_Phi.TupleGreater(hv_pi*0.25))) != 0)
          {
            hv_Phi = hv_Phi-(hv_pi/2);
          }
          if ((int)(new HTuple(hv_Phi.TupleLess((-hv_pi)*0.25))) != 0)
          {
            hv_Phi = hv_Phi+(hv_pi/2);
          }
        }

        //角度不能大于45度 30度  ,需要增加告警，否则电池可能抓斜
        if ((int)(new HTuple(((((hv_Phi*57.3)).TupleAbs())).TupleGreater(35))) != 0)
        {
          //by JT 20181207
          disp_message(hv_owindowHandle, "Over 35 degree", "window", 100, 120, "red", 
              "true");

          ho_image_original.Dispose();
          ho_RectangleROI.Dispose();
          ho_ImageReducedS.Dispose();
          ho_RegionS.Dispose();
          ho_ConnectedRegionsS.Dispose();
          ho_SelectedRegionsSAll_0.Dispose();
          ho_SelectedRegionsSAll.Dispose();
          ho_SelectedRegionsS.Dispose();
          ho_ImageRotateS.Dispose();
          ho_ImageReducedS2.Dispose();
          ho_RegionS2.Dispose();
          ho_RegionFillUp.Dispose();
          ho_RegionLinesFitBottomRow.Dispose();
          ho_RegionLinesFitRightCol.Dispose();
          ho_workingRegion.Dispose();
          ho_SelectedRegionsSBody.Dispose();
          ho_Rectangle_body.Dispose();
          ho_Circle_Rotated.Dispose();
          ho_Circle_cen.Dispose();
          ho_Circle.Dispose();
          ho_FitBottomRowRotated.Dispose();
          ho_FitRightColRotated.Dispose();
                    for (int i = 0; i < 20; i++)
                    {
                        OTemp[i].Dispose();
                    }
                    return;
        }

        //2)把电芯转正，然后再进行处理
        //rotation images to horizontal
        ho_ImageRotateS.Dispose();
        HOperatorSet.RotateImage(ho_ImageReducedS, out ho_ImageRotateS, ((-hv_Phi)*180)/3.1416, 
            "constant");
        //********极耳反向报警处理
        Tab_orientation_Insp(ho_ImageRotateS, ho_RectangleROI, hv_owindowHandle, 
            hv_m_maxgray_find_contour, hv_height_body, hv_width_total, hv_m_possiblearea_2ndcol1, 
            hv_m_possiblearea_2ndcol2, hv_Blk_and_Wht, out hv_bResultTabOri, out hv_Column2, 
            out hv_Row2);
        if ((int)(new HTuple(hv_bResultTabOri.TupleEqual(1))) != 0)
        {
          disp_message(hv_owindowHandle, "Tab anti-orientation", "window", 100, 120, 
              "red", "true");
          ho_image_original.Dispose();
          ho_RectangleROI.Dispose();
          ho_ImageReducedS.Dispose();
          ho_RegionS.Dispose();
          ho_ConnectedRegionsS.Dispose();
          ho_SelectedRegionsSAll_0.Dispose();
          ho_SelectedRegionsSAll.Dispose();
          ho_SelectedRegionsS.Dispose();
          ho_ImageRotateS.Dispose();
          ho_ImageReducedS2.Dispose();
          ho_RegionS2.Dispose();
          ho_RegionFillUp.Dispose();
          ho_RegionLinesFitBottomRow.Dispose();
          ho_RegionLinesFitRightCol.Dispose();
          ho_workingRegion.Dispose();
          ho_SelectedRegionsSBody.Dispose();
          ho_Rectangle_body.Dispose();
          ho_Circle_Rotated.Dispose();
          ho_Circle_cen.Dispose();
          ho_Circle.Dispose();
          ho_FitBottomRowRotated.Dispose();
          ho_FitRightColRotated.Dispose();
                    for (int i = 0; i < 20; i++)
                    {
                        OTemp[i].Dispose();
                    }
                    return;
        }
        else
        {
        }

        HOperatorSet.DispImage(ho_ImageRotateS, hv_owindowHandle);

        //***********对叠料的处理by chen20190920 (BIS通讯还一样可能存在问题)
        if ((int)((new HTuple(hv_Area.TupleGreater((1.15*hv_height_body)*hv_width_total))).TupleAnd(
            new HTuple(hv_Area.TupleLess((1.8*hv_height_body)*hv_width_total)))) != 0)
        {
          disp_message(hv_owindowHandle, "Stack by Stack", "window", 100, 120, "red", 
              "true");
          ho_image_original.Dispose();
          ho_RectangleROI.Dispose();
          ho_ImageReducedS.Dispose();
          ho_RegionS.Dispose();
          ho_ConnectedRegionsS.Dispose();
          ho_SelectedRegionsSAll_0.Dispose();
          ho_SelectedRegionsSAll.Dispose();
          ho_SelectedRegionsS.Dispose();
          ho_ImageRotateS.Dispose();
          ho_ImageReducedS2.Dispose();
          ho_RegionS2.Dispose();
          ho_RegionFillUp.Dispose();
          ho_RegionLinesFitBottomRow.Dispose();
          ho_RegionLinesFitRightCol.Dispose();
          ho_workingRegion.Dispose();
          ho_SelectedRegionsSBody.Dispose();
          ho_Rectangle_body.Dispose();
          ho_Circle_Rotated.Dispose();
          ho_Circle_cen.Dispose();
          ho_Circle.Dispose();
          ho_FitBottomRowRotated.Dispose();
          ho_FitRightColRotated.Dispose();
                    for (int i = 0; i < 20; i++)
                    {
                        OTemp[i].Dispose();
                    }
                    return;
        }
        else if ((int)(new HTuple(hv_Area.TupleGreater((1.8*hv_height_body)*hv_width_total))) != 0)
        {

          ho_RectangleROI.Dispose();
          HOperatorSet.GenRectangle1(out ho_RectangleROI, hv_Row2-hv_height_body, 
              hv_Column2-(hv_width_body/1.2), hv_Row2+20, hv_Column2+20);
        }




        //get workign region for the body
        ho_ImageReducedS2.Dispose();
        HOperatorSet.ReduceDomain(ho_ImageRotateS, ho_RectangleROI, out ho_ImageReducedS2
            );
        //emphasize (ImageReducedS2, ImageReducedS2, 10, 10, 2)
        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(1))) != 0)
        {
          //threshold (ImageReducedS2, RegionS2, 200, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS2, out ho_RegionS2, 200, 255);
        }
        else
        {
          //threshold (ImageReducedS2, RegionS2, 0, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS2, out ho_RegionS2, 0, 80);
        }
        ho_RegionFillUp.Dispose();
        HOperatorSet.FillUp(ho_RegionS2, out ho_RegionFillUp);
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.Connection(ho_RegionFillUp, out ho_ConnectedRegionsS);
        OTemp[SP_O] = ho_ConnectedRegionsS.CopyObj(1,-1);
        SP_O++;
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.FillUp(OTemp[SP_O-1], out ho_ConnectedRegionsS);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        HOperatorSet.DispObj(ho_ConnectedRegionsS, hv_owindowHandle);

        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegionsS, out ho_SelectedRegionsSAll, 
            ((new HTuple("area")).TupleConcat("height")).TupleConcat("width"), "and", 
            ((((((hv_height_body*hv_width_total)*3)/4)).TupleConcat(hv_height_body/2))).TupleConcat(
            hv_width_total/2), (((((hv_height_body*hv_width_total)*1.3)).TupleConcat(
            hv_height_body*2.2))).TupleConcat(hv_width_total*1.5));



        OTemp[SP_O] = ho_SelectedRegionsSAll.CopyObj(1,-1);
        SP_O++;
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SortRegion(OTemp[SP_O-1], out ho_SelectedRegionsSAll, "lower_right", 
            "false", "column");
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        ho_SelectedRegionsS.Dispose();
        HOperatorSet.SelectObj(ho_SelectedRegionsSAll, out ho_SelectedRegionsS, 1);

        HOperatorSet.SmallestRectangle1(ho_SelectedRegionsS, out hv_Row1RectOut, 
            out hv_Col1RectOut, out hv_Row2RectOut, out hv_Col2RectOut);
        //use green image to identify battery body
        //旋转后电池不能处于视野的边界,如果已经处于右边界，需要增加告警，否则电池可能被推跌落!!!
        if ((int)((new HTuple((new HTuple((new HTuple(hv_Row1RectOut.TupleLessEqual(
            hv_m_possiblearea_2ndrow1+1))).TupleOr(new HTuple(hv_Col1RectOut.TupleLessEqual(
            hv_m_possiblearea_2ndcol1+1))))).TupleOr(new HTuple(hv_Row2RectOut.TupleGreaterEqual(
            hv_m_possiblearea_2ndrow2-1))))).TupleOr(new HTuple(hv_Col2RectOut.TupleGreaterEqual(
            hv_m_possiblearea_2ndcol2-1)))) != 0)
        {
          //by JT 20181207
          disp_message(hv_owindowHandle, "No Battery in the field of view", "window", 
              100, 120, "red", "true");
          ho_image_original.Dispose();
          ho_RectangleROI.Dispose();
          ho_ImageReducedS.Dispose();
          ho_RegionS.Dispose();
          ho_ConnectedRegionsS.Dispose();
          ho_SelectedRegionsSAll_0.Dispose();
          ho_SelectedRegionsSAll.Dispose();
          ho_SelectedRegionsS.Dispose();
          ho_ImageRotateS.Dispose();
          ho_ImageReducedS2.Dispose();
          ho_RegionS2.Dispose();
          ho_RegionFillUp.Dispose();
          ho_RegionLinesFitBottomRow.Dispose();
          ho_RegionLinesFitRightCol.Dispose();
          ho_workingRegion.Dispose();
          ho_SelectedRegionsSBody.Dispose();
          ho_Rectangle_body.Dispose();
          ho_Circle_Rotated.Dispose();
          ho_Circle_cen.Dispose();
          ho_Circle.Dispose();
          ho_FitBottomRowRotated.Dispose();
          ho_FitRightColRotated.Dispose();
                    for (int i = 0; i < 20; i++)
                    {
                        OTemp[i].Dispose();
                    }
                    return;
        }

        //3)边缘拟合，查找右下角的点
        ho_RegionLinesFitBottomRow.Dispose();
        fitBottomRowLine(ho_ImageRotateS, ho_SelectedRegionsS, out ho_RegionLinesFitBottomRow
            );

        ho_RegionLinesFitRightCol.Dispose();
        fitRightSideLine(ho_ImageRotateS, ho_SelectedRegionsS, out ho_RegionLinesFitRightCol
            );


        //concat_obj (RegionLinesFit, RegionLinesFitSide, RegionLinesFit)
        HOperatorSet.SmallestRectangle1(ho_RegionLinesFitBottomRow, out hv_Row11LinesFit, 
            out hv_Column11LinesFit, out hv_Row21LinesFit, out hv_Column21LinesFit);
        //*     endfor
        HOperatorSet.SmallestRectangle1(ho_RegionLinesFitRightCol, out hv_Row11LineFitRight, 
            out hv_Column11LineFitRight, out hv_Row21LineFitRight, out hv_Column21LineFitRight);

        //外接矩形可能有毛刺
        //内接矩形可能有凹陷
        //拟合的直线可能会错误
        //进一步参考判断
        ho_workingRegion.Dispose();
        HOperatorSet.GenRectangle1(out ho_workingRegion, hv_Row1RectOut+(hv_height_body/2), 
            hv_Col1RectOut, hv_Row2RectOut+60, hv_Col2RectOut);
        ho_SelectedRegionsSBody.Dispose();
        HOperatorSet.Intersection(ho_SelectedRegionsS, ho_workingRegion, out ho_SelectedRegionsSBody
            );
        HOperatorSet.InnerRectangle1(ho_SelectedRegionsSBody, out hv_Row1SRectInn, 
            out hv_Col1SRectInn, out hv_Row2SRectInn, out hv_Col2SRectInn);

        //一般情况下的row和column，内接in<= 拟合fit <=外接out, 综合三个数据
        hv_Row2Using = hv_Row2SRectInn.Clone();
        if ((int)(new HTuple(hv_Row21LinesFit.TupleGreater(0))) != 0)
        {
          if ((int)((new HTuple(((((hv_Row21LinesFit-hv_Row2RectOut)).TupleAbs())).TupleGreater(
              10))).TupleAnd(new HTuple(((((hv_Row21LinesFit-hv_Row2SRectInn)).TupleAbs()
              )).TupleLess(10)))) != 0)
          {
            hv_Row2Using = hv_Row21LinesFit+4;
          }
          else if ((int)((new HTuple(((((hv_Row21LinesFit-hv_Row2RectOut)).TupleAbs()
              )).TupleLess(10))).TupleAnd(new HTuple(((((hv_Row21LinesFit-hv_Row2SRectInn)).TupleAbs()
              )).TupleGreater(10)))) != 0)
          {
            hv_Row2Using = hv_Row21LinesFit-4;
          }
          else
          {
            hv_Row2Using = ((hv_Row2SRectInn+hv_Row21LinesFit)+hv_Row2RectOut)/3;
          }
        }

        hv_Col2Using = hv_Col2SRectInn.Clone();
        if ((int)(new HTuple(hv_Column21LineFitRight.TupleGreater(0))) != 0)
        {
          if ((int)((new HTuple(((((hv_Column21LineFitRight-hv_Col2RectOut)).TupleAbs()
              )).TupleGreater(10))).TupleAnd(new HTuple(((((hv_Column21LineFitRight-hv_Col2SRectInn)).TupleAbs()
              )).TupleLess(10)))) != 0)
          {
            hv_Col2Using = hv_Column21LineFitRight+4;
          }
          else if ((int)((new HTuple(((((hv_Column21LineFitRight-hv_Col2RectOut)).TupleAbs()
              )).TupleLess(10))).TupleAnd(new HTuple(((((hv_Column21LineFitRight-hv_Col2SRectInn)).TupleAbs()
              )).TupleGreater(10)))) != 0)
          {
            hv_Col2Using = hv_Column21LineFitRight-4;
          }
          else
          {
            hv_Col2Using = ((hv_Col2SRectInn+hv_Column21LineFitRight)+hv_Col2RectOut)/3;
          }
        }


        //3)根据右下角和电芯标准尺寸获得主体区域
        ho_Rectangle_body.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle_body, hv_Row2Using-hv_height_body, 
            hv_Col2Using-hv_width_body, hv_Row2Using, hv_Col2Using);
        HOperatorSet.SmallestRectangle1(ho_Rectangle_body, out hv_Row11, out hv_Column11, 
            out hv_Row21, out hv_Column21);

        HOperatorSet.SetColor(hv_owindowHandle, "green");
        HOperatorSet.DispObj(ho_Rectangle_body, hv_owindowHandle);
        //计算中心点
        //center of the bettery(including the top strip)
        hv_x_centerRaw = (hv_Row11+hv_Row21)/2;
        if ((int)(new HTuple(hv_Column21.TupleGreaterEqual(hv_m_possiblearea_2ndcol2-10))) != 0)
        {
          //or throw an exception the battery is out of vision area
          hv_y_centerRaw = hv_Column11+(hv_width_body/2);
        }
        else
        {
          hv_y_centerRaw = (hv_Column11+hv_Column21)/2;
        }
        //x_centerRaw := Row21 - height_body/2
        //y_centerRaw := Column21-width_total/2
        //整合偏移量
        hv_x_c1 = hv_x_centerRaw+hv_m_offset_catching_row;
        hv_y_c1 = hv_y_centerRaw+hv_m_offset_catching_col;


        ho_Circle_Rotated.Dispose();
        HOperatorSet.GenCircle(out ho_Circle_Rotated, hv_x_c1, hv_y_c1, 10);
        HOperatorSet.DispObj(ho_Circle_Rotated, hv_owindowHandle);

        HOperatorSet.SetColor(hv_owindowHandle, "yellow");
        ho_Circle_cen.Dispose();
        HOperatorSet.GenCircle(out ho_Circle_cen, hv_m_row_image_center, hv_m_col_image_center, 
            10);
        HOperatorSet.DispObj(ho_Circle_cen, hv_owindowHandle);


        //=============5）生成结果/包含显示图片
        //4)转化到原图（旋转前的图片上）

        hv_dx = hv_x_c1-hv_m_row_image_center;
        hv_dy = hv_y_c1-hv_m_col_image_center;
        hv_ds = (hv_dx*hv_dx)+(hv_dy*hv_dy);
        //distance to center
        HOperatorSet.TupleSqrt(hv_ds, out hv_r);
        HOperatorSet.TupleAtan2(hv_dy.TupleAbs(), hv_dx.TupleAbs(), out hv_Theta);
        //recover center before rotation
        hv_Alpha = hv_Phi.Clone();
        if ((int)(new HTuple(((hv_dy*hv_dx)).TupleLess(0))) != 0)
        {
          hv_Alpha = -hv_Phi;
        }

        hv_dx2 = hv_r*((((hv_Theta+hv_Alpha)+hv_m_degreerotate_between_axes)).TupleCos()
            );
        hv_dy2 = hv_r*((((hv_Theta+hv_Alpha)+hv_m_degreerotate_between_axes)).TupleSin()
            );

        HOperatorSet.TupleSgn((hv_dx*1.0)/hv_r, out hv_Sgn_x);
        HOperatorSet.TupleSgn((hv_dy*1.0)/hv_r, out hv_Sgn_y);

        hv_x_c = hv_m_row_image_center+(hv_dx2*hv_Sgn_x);
        hv_y_c = hv_m_col_image_center+(hv_dy2*hv_Sgn_y);


        HOperatorSet.DispObj(ho_Image, hv_owindowHandle);
        ho_Circle.Dispose();
        HOperatorSet.GenCircle(out ho_Circle, hv_x_c, hv_y_c, 10);
        HOperatorSet.SetColor(hv_owindowHandle, "green");
        HOperatorSet.DispObj(ho_Circle_cen, hv_owindowHandle);
        HOperatorSet.SetColor(hv_owindowHandle, "green");
        HOperatorSet.DispObj(ho_Circle, hv_owindowHandle);
        //stop ()
        //***********************************

        hv_angle_out = (hv_Phi*180)/3.14159;

        hv_Delta_x = (hv_x_c-hv_m_target_row)*hv_m_scale_pixel_to_mm;
        hv_Delta_y = (hv_y_c-hv_m_target_column)*hv_m_scale_pixel_to_mm;

        //显示两条拟合的直线，用于定位结果调试

        ho_FitBottomRowRotated.Dispose();
        rotateaxis_rectangle2(ho_RegionLinesFitBottomRow, out ho_FitBottomRowRotated, 
            hv_m_row_image_center, hv_m_col_image_center, hv_Phi, hv_m_degreerotate_between_axes);
        ho_FitRightColRotated.Dispose();
        rotateaxis_rectangle2(ho_RegionLinesFitRightCol, out ho_FitRightColRotated, 
            hv_m_row_image_center, hv_m_col_image_center, hv_Phi, hv_m_degreerotate_between_axes);

        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        HOperatorSet.DispObj(ho_Circle_cen, hv_owindowHandle);
        HOperatorSet.DispObj(ho_FitBottomRowRotated, hv_owindowHandle);
        HOperatorSet.DispObj(ho_FitRightColRotated, hv_owindowHandle);


        HOperatorSet.SetColor(hv_owindowHandle, "red");

      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);

      }

      ho_image_original.Dispose();
      ho_RectangleROI.Dispose();
      ho_ImageReducedS.Dispose();
      ho_RegionS.Dispose();
      ho_ConnectedRegionsS.Dispose();
      ho_SelectedRegionsSAll_0.Dispose();
      ho_SelectedRegionsSAll.Dispose();
      ho_SelectedRegionsS.Dispose();
      ho_ImageRotateS.Dispose();
      ho_ImageReducedS2.Dispose();
      ho_RegionS2.Dispose();
      ho_RegionFillUp.Dispose();
      ho_RegionLinesFitBottomRow.Dispose();
      ho_RegionLinesFitRightCol.Dispose();
      ho_workingRegion.Dispose();
      ho_SelectedRegionsSBody.Dispose();
      ho_Rectangle_body.Dispose();
      ho_Circle_Rotated.Dispose();
      ho_Circle_cen.Dispose();
      ho_Circle.Dispose();
      ho_FitBottomRowRotated.Dispose();
      ho_FitRightColRotated.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            result = 0;
      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_image_original.Dispose();
      ho_RectangleROI.Dispose();
      ho_ImageReducedS.Dispose();
      ho_RegionS.Dispose();
      ho_ConnectedRegionsS.Dispose();
      ho_SelectedRegionsSAll_0.Dispose();
      ho_SelectedRegionsSAll.Dispose();
      ho_SelectedRegionsS.Dispose();
      ho_ImageRotateS.Dispose();
      ho_ImageReducedS2.Dispose();
      ho_RegionS2.Dispose();
      ho_RegionFillUp.Dispose();
      ho_RegionLinesFitBottomRow.Dispose();
      ho_RegionLinesFitRightCol.Dispose();
      ho_workingRegion.Dispose();
      ho_SelectedRegionsSBody.Dispose();
      ho_Rectangle_body.Dispose();
      ho_Circle_Rotated.Dispose();
      ho_Circle_cen.Dispose();
      ho_Circle.Dispose();
      ho_FitBottomRowRotated.Dispose();
      ho_FitRightColRotated.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            throw HDevExpDefaultException;
    }
  }

  public void fitBottomRowLine (HObject ho_ImageRotateS, HObject ho_BatteryNoTabRegions, 
      out HObject ho_RegionLinesFitSide)
  {


    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];
    long SP_O = 0;
        for (int i = 0; i < 20; i++)
        {
            HOperatorSet.GenEmptyObj(out OTemp[i]);
        }
    // Local iconic variables 

    HObject ho_SelectedRegionsS, ho_BatteryNoTabRegionsOut;
    HObject ho_BatteryNoTabRegionsRect, ho_sliceRectRegions;
    HObject ho_sliceRectRegionsROI, ho_sliceRectRegionsROIRaw;
    HObject ho_sliceobjRectsssssssRemoved, ho_objNoTabRegionRect=null;
    HObject ho_sliceRectobjNoTabRegions=null, ho_sliceobjRectRemoved=null;
    HObject ho_RegionLinesFit, ho_sliceRectRegionsROISide, ho_ContoursliceRectRegionsROI;


    // Local control variables 

    HTuple hv_Row1RectOut, hv_Col1RectOut, hv_Row2RectOut;
    HTuple hv_Col2RectOut, hv_Row1BatteryNoTab, hv_Col1BatteryNoTab;
    HTuple hv_Row2BatteryNoTab, hv_Col2BatteryNoTab, hv_lengthOfNoTabRegion;
    HTuple hv_numberOfNoTabRegion, hv_subindex, hv_totalLen;
    HTuple hv_stepOflen, hv_sliceRectRow1, hv_sliceRectRow2;
    HTuple hv_sliceRectCol1, hv_sliceRectCol2, hv_sliceIndexGap;
    HTuple hv_countOfleftTop=new HTuple(), hv_sliceIndex=new HTuple();
    HTuple hv_Row1sliceRect, hv_Col1sliceRect, hv_Row2sliceRect;
    HTuple hv_Col2sliceRect, hv_Row1SLobjNoTab=new HTuple();
    HTuple hv_Col1SLobjNoTab=new HTuple(), hv_Row2SLobjNoTab=new HTuple();
    HTuple hv_Col2SLobjNoTab=new HTuple(), hv_lenofRow1SLobjNoTab=new HTuple();
    HTuple hv_Row1SLobjNoTabPLine=new HTuple(), hv_Row1SLobjNoTabPLIndex=new HTuple();
    HTuple hv_Values, hv_isideTab, hv_len, hv_y, hv_x, hv_xxxx;
    HTuple hv_idxxxx, hv_xtx, hv_xty, hv_invxtx, hv_beta, hv_Valueside;
    HTuple hv_towPointsCol, hv_Newy, hv_RowBegin, hv_ColBegin;
    HTuple hv_RowEnd, hv_ColEnd, hv_Nr, hv_Nc, hv_Dist;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFitSide);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsS);
    HOperatorSet.GenEmptyObj(out ho_BatteryNoTabRegionsOut);
    HOperatorSet.GenEmptyObj(out ho_BatteryNoTabRegionsRect);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegions);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROI);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROIRaw);
    HOperatorSet.GenEmptyObj(out ho_sliceobjRectsssssssRemoved);
    HOperatorSet.GenEmptyObj(out ho_objNoTabRegionRect);
    HOperatorSet.GenEmptyObj(out ho_sliceRectobjNoTabRegions);
    HOperatorSet.GenEmptyObj(out ho_sliceobjRectRemoved);
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFit);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROISide);
    HOperatorSet.GenEmptyObj(out ho_ContoursliceRectRegionsROI);

    try
    {
      ho_SelectedRegionsS.Dispose();
      HOperatorSet.CopyObj(ho_BatteryNoTabRegions, out ho_SelectedRegionsS, 1, -1);
      //10.拟合底部直线进行拟合直线前的准备
      //剔除左边侧封区域
      //剔除每个区域的边缘
      //剔除区域内的最高点14%（当采样数量大于15时）
      ho_RegionLinesFitSide.Dispose();
      HOperatorSet.GenEmptyObj(out ho_RegionLinesFitSide);
      //shape_trans (BatteryNoTabRegionsOut, BatteryNoTabRegionsOut, 'convex')
      HOperatorSet.SmallestRectangle1(ho_SelectedRegionsS, out hv_Row1RectOut, out hv_Col1RectOut, 
          out hv_Row2RectOut, out hv_Col2RectOut);
      ho_BatteryNoTabRegionsOut.Dispose();
      HOperatorSet.SortRegion(ho_SelectedRegionsS, out ho_BatteryNoTabRegionsOut, 
          "upper_left", "true", "column");
      HOperatorSet.SmallestRectangle1(ho_BatteryNoTabRegionsOut, out hv_Row1BatteryNoTab, 
          out hv_Col1BatteryNoTab, out hv_Row2BatteryNoTab, out hv_Col2BatteryNoTab);
      ho_BatteryNoTabRegionsRect.Dispose();
      HOperatorSet.GenRectangle1(out ho_BatteryNoTabRegionsRect, hv_Row1BatteryNoTab, 
          hv_Col1BatteryNoTab, hv_Row2BatteryNoTab, hv_Col2BatteryNoTab);
      OTemp[SP_O] = ho_BatteryNoTabRegionsRect.CopyObj(1,-1);
      SP_O++;
      ho_BatteryNoTabRegionsRect.Dispose();
      HOperatorSet.Connection(OTemp[SP_O-1], out ho_BatteryNoTabRegionsRect);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      hv_lengthOfNoTabRegion = hv_Col2BatteryNoTab-hv_Col1BatteryNoTab;
      hv_numberOfNoTabRegion = new HTuple(hv_Row1BatteryNoTab.TupleLength());
      //剔除最左边的区域侧边封印区域
      if ((int)(new HTuple(((hv_lengthOfNoTabRegion.TupleSelect(0))).TupleGreater(
          160))) != 0)
      {
        hv_Col1BatteryNoTab[0] = (hv_Col1BatteryNoTab.TupleSelect(0))+10;
        hv_Col2BatteryNoTab[0] = (hv_Col2BatteryNoTab.TupleSelect(0))-10;
      }
      for (hv_subindex=1; hv_subindex.Continue(hv_numberOfNoTabRegion-1, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        if ((int)(new HTuple(((hv_lengthOfNoTabRegion.TupleSelect(hv_subindex))).TupleGreater(
            10))) != 0)
        {
          hv_Col1BatteryNoTab[hv_subindex] = (hv_Col1BatteryNoTab.TupleSelect(hv_subindex))+5;
          hv_Col2BatteryNoTab[hv_subindex] = (hv_Col2BatteryNoTab.TupleSelect(hv_subindex))-5;
        }
      }
      hv_lengthOfNoTabRegion = hv_Col2BatteryNoTab-hv_Col1BatteryNoTab;
      HOperatorSet.TupleSum(hv_lengthOfNoTabRegion, out hv_totalLen);
      hv_stepOflen = (hv_totalLen-200)/50;
      if ((int)(new HTuple(hv_stepOflen.TupleLess(2))) != 0)
      {
        hv_stepOflen = 2;
      }
      hv_sliceRectRow1 = new HTuple();
      hv_sliceRectRow2 = new HTuple();
      hv_sliceRectCol1 = new HTuple();
      hv_sliceRectCol2 = new HTuple();
      hv_sliceIndexGap = 0;
      for (hv_subindex=0; hv_subindex.Continue(hv_numberOfNoTabRegion-1, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        hv_countOfleftTop = (hv_lengthOfNoTabRegion.TupleSelect(hv_subindex))/hv_stepOflen;

        for (hv_sliceIndex=hv_sliceIndexGap; hv_sliceIndex.Continue(hv_sliceIndexGap+hv_countOfleftTop, 1); hv_sliceIndex = hv_sliceIndex.TupleAdd(1))
        {
          hv_sliceRectRow1[hv_sliceIndex] = (hv_Row2BatteryNoTab.TupleSelect(hv_subindex))-30;
          hv_sliceRectRow2[hv_sliceIndex] = (hv_Row2BatteryNoTab.TupleSelect(hv_subindex))+30;
          hv_sliceRectCol1[hv_sliceIndex] = (hv_Col1BatteryNoTab.TupleSelect(hv_subindex))+((hv_sliceIndex-hv_sliceIndexGap)*hv_stepOflen);
          hv_sliceRectCol2[hv_sliceIndex] = (hv_Col1BatteryNoTab.TupleSelect(hv_subindex))+((hv_sliceIndex-hv_sliceIndexGap)*hv_stepOflen);
        }

        hv_sliceIndexGap = hv_sliceIndexGap+hv_countOfleftTop;

      }


      ho_sliceRectRegions.Dispose();
      HOperatorSet.GenRectangle1(out ho_sliceRectRegions, hv_sliceRectRow1, hv_sliceRectCol1, 
          hv_sliceRectRow2, hv_sliceRectCol2);
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Intersection(ho_sliceRectRegions, ho_BatteryNoTabRegionsOut, out ho_sliceRectRegionsROI
          );
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.ClosingRectangle1(OTemp[SP_O-1], out ho_sliceRectRegionsROI, 1, 
          60);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Union1(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.FillUp(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Connection(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.SortRegion(OTemp[SP_O-1], out ho_sliceRectRegionsROI, "upper_left", 
          "true", "column");
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      HOperatorSet.SmallestRectangle1(ho_sliceRectRegionsROI, out hv_Row1sliceRect, 
          out hv_Col1sliceRect, out hv_Row2sliceRect, out hv_Col2sliceRect);
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.GenRectangle1(out ho_sliceRectRegionsROI, hv_Row2sliceRect, hv_Col1sliceRect, 
          hv_Row2sliceRect, hv_Col2sliceRect);
      ho_sliceRectRegionsROIRaw.Dispose();
      HOperatorSet.Connection(ho_sliceRectRegionsROI, out ho_sliceRectRegionsROIRaw
          );


      //如果同一区域超出15个点,剔除最靠近上方的5个点
      ho_sliceobjRectsssssssRemoved.Dispose();
      HOperatorSet.GenEmptyObj(out ho_sliceobjRectsssssssRemoved);
      for (hv_subindex=1; hv_subindex.Continue(hv_numberOfNoTabRegion, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        ho_objNoTabRegionRect.Dispose();
        HOperatorSet.SelectObj(ho_BatteryNoTabRegionsRect, out ho_objNoTabRegionRect, 
            hv_subindex);
        ho_sliceRectobjNoTabRegions.Dispose();
        HOperatorSet.Intersection(ho_objNoTabRegionRect, ho_sliceRectRegionsROIRaw, 
            out ho_sliceRectobjNoTabRegions);
        OTemp[SP_O] = ho_sliceRectobjNoTabRegions.CopyObj(1,-1);
        SP_O++;
        ho_sliceRectobjNoTabRegions.Dispose();
        HOperatorSet.Connection(OTemp[SP_O-1], out ho_sliceRectobjNoTabRegions);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        HOperatorSet.SmallestRectangle1(ho_sliceRectobjNoTabRegions, out hv_Row1SLobjNoTab, 
            out hv_Col1SLobjNoTab, out hv_Row2SLobjNoTab, out hv_Col2SLobjNoTab);
        hv_lenofRow1SLobjNoTab = new HTuple(hv_Row1SLobjNoTab.TupleLength());
        if ((int)(new HTuple(hv_lenofRow1SLobjNoTab.TupleGreater(15))) != 0)
        {
          HOperatorSet.TupleSortIndex(hv_Row1SLobjNoTab, out hv_Row1SLobjNoTabPLine);
          HOperatorSet.TupleSelectRange(hv_Row1SLobjNoTabPLine, 0, (hv_lenofRow1SLobjNoTab/7)-1, 
              out hv_Row1SLobjNoTabPLine);
          hv_Row1SLobjNoTabPLIndex = hv_Row1SLobjNoTabPLine+1;
          ho_sliceobjRectRemoved.Dispose();
          HOperatorSet.SelectObj(ho_sliceRectobjNoTabRegions, out ho_sliceobjRectRemoved, 
              hv_Row1SLobjNoTabPLIndex);
          OTemp[SP_O] = ho_sliceobjRectsssssssRemoved.CopyObj(1,-1);
          SP_O++;
          ho_sliceobjRectsssssssRemoved.Dispose();
          HOperatorSet.ConcatObj(OTemp[SP_O-1], ho_sliceobjRectRemoved, out ho_sliceobjRectsssssssRemoved
              );
          OTemp[SP_O-1].Dispose();
          SP_O = 0;
        }
      }
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Difference(OTemp[SP_O-1], ho_sliceobjRectsssssssRemoved, out ho_sliceRectRegionsROI
          );
      OTemp[SP_O-1].Dispose();
      SP_O = 0;



      //11.以tab为界限,分别拟合直线?不行，如果相差比较远会得到很奇怪的拟合线
      ho_RegionLinesFit.Dispose();
      HOperatorSet.GenEmptyObj(out ho_RegionLinesFit);
      hv_Values = new HTuple();
      hv_Values[0] = 0;
      hv_Values[1] = 0;
      hv_Values[2] = 0;
      hv_Values[3] = 0;
      hv_isideTab = 2;
      //* for isideTab := 0 to 1 by 1
      //gen_empty_obj (sliceRectRegionsROISide)
      //if (isideTab=0)
        //concat_obj (sliceRectRegionsROISide, defineInnerRectsLeft, sliceRectRegionsROISide)
      //elseif (isideTab=1)
        //concat_obj (sliceRectRegionsROISide, defineInnerRectsRight, sliceRectRegionsROISide)
      //else
        //concat_obj (sliceRectRegionsROISide, defineInnerRects, sliceRectRegionsROISide)
      //endif
      //intersection (sliceRectRegionsROI, sliceRectRegionsROISide, sliceRectRegionsROISide)
      ho_sliceRectRegionsROISide.Dispose();
      HOperatorSet.SortRegion(ho_sliceRectRegionsROI, out ho_sliceRectRegionsROISide, 
          "upper_left", "true", "column");
      HOperatorSet.SmallestRectangle1(ho_sliceRectRegionsROISide, out hv_Row1sliceRect, 
          out hv_Col1sliceRect, out hv_Row2sliceRect, out hv_Col2sliceRect);

      hv_len = new HTuple(hv_Row2sliceRect.TupleLength());
      HOperatorSet.CreateMatrix(hv_len, 1, hv_Row2sliceRect, out hv_y);
      HOperatorSet.CreateMatrix(hv_len, 2, 1, out hv_x);
      hv_xxxx = new HTuple();
      for (hv_idxxxx=0; hv_idxxxx.Continue(hv_len-1, 1); hv_idxxxx = hv_idxxxx.TupleAdd(1))
      {
        hv_xxxx[hv_idxxxx] = hv_idxxxx;
      }
      HOperatorSet.SetValueMatrix(hv_x, hv_xxxx, HTuple.TupleGenConst(hv_len,0), 
          hv_Col2sliceRect);

      HOperatorSet.MultMatrix(hv_x, hv_x, "ATB", out hv_xtx);
      HOperatorSet.MultMatrix(hv_x, hv_y, "ATB", out hv_xty);

      HOperatorSet.InvertMatrix(hv_xtx, "general", 0, out hv_invxtx);
      HOperatorSet.MultMatrix(hv_invxtx, hv_xty, "AB", out hv_beta);
      HOperatorSet.GetFullMatrix(hv_beta, out hv_Valueside);

      hv_Values[(hv_isideTab*2)+0] = hv_Valueside.TupleSelect(0);
      hv_Values[(hv_isideTab*2)+1] = hv_Valueside.TupleSelect(1);
      hv_towPointsCol = new HTuple();
      hv_towPointsCol = hv_towPointsCol.TupleConcat(hv_Col1RectOut);
      hv_towPointsCol = hv_towPointsCol.TupleConcat(hv_Col2RectOut);
      //if (isideTab=0)
        //towPointsCol := [300,Col1Tab[1]]
      //elseif (isideTab=1)
        //towPointsCol := [Col2Tab[0],Col2Tab[1]+700]
      //else
        //isideTab := 0
        //Values[isideTab*2+0] := Valueside[0]
        //Values[isideTab*2+1] := Valueside[1]
        //towPointsCol := [300,Col2Tab[1]+700]
      //endif

      hv_Newy = ((hv_Values.TupleSelect((hv_isideTab*2)+0))*hv_towPointsCol)+(hv_Values.TupleSelect(
          (hv_isideTab*2)+1));

      ho_ContoursliceRectRegionsROI.Dispose();
      HOperatorSet.GenContourPolygonXld(out ho_ContoursliceRectRegionsROI, hv_Newy, 
          hv_towPointsCol);
      HOperatorSet.FitLineContourXld(ho_ContoursliceRectRegionsROI, "gauss", -1, 
          0, 5, 1, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, 
          out hv_Nr, out hv_Nc, out hv_Dist);
      ho_RegionLinesFitSide.Dispose();
      HOperatorSet.GenRegionLine(out ho_RegionLinesFitSide, hv_RowBegin, hv_ColBegin, 
          hv_RowEnd, hv_ColEnd);
      ho_SelectedRegionsS.Dispose();
      ho_BatteryNoTabRegionsOut.Dispose();
      ho_BatteryNoTabRegionsRect.Dispose();
      ho_sliceRectRegions.Dispose();
      ho_sliceRectRegionsROI.Dispose();
      ho_sliceRectRegionsROIRaw.Dispose();
      ho_sliceobjRectsssssssRemoved.Dispose();
      ho_objNoTabRegionRect.Dispose();
      ho_sliceRectobjNoTabRegions.Dispose();
      ho_sliceobjRectRemoved.Dispose();
      ho_RegionLinesFit.Dispose();
      ho_sliceRectRegionsROISide.Dispose();
      ho_ContoursliceRectRegionsROI.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_SelectedRegionsS.Dispose();
      ho_BatteryNoTabRegionsOut.Dispose();
      ho_BatteryNoTabRegionsRect.Dispose();
      ho_sliceRectRegions.Dispose();
      ho_sliceRectRegionsROI.Dispose();
      ho_sliceRectRegionsROIRaw.Dispose();
      ho_sliceobjRectsssssssRemoved.Dispose();
      ho_objNoTabRegionRect.Dispose();
      ho_sliceRectobjNoTabRegions.Dispose();
      ho_sliceobjRectRemoved.Dispose();
      ho_RegionLinesFit.Dispose();
      ho_sliceRectRegionsROISide.Dispose();
      ho_ContoursliceRectRegionsROI.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            throw HDevExpDefaultException;
    }
  }

  public void fitRightSideLine (HObject ho_ImageRotateS, HObject ho_BatteryNoTabRegions, 
      out HObject ho_RegionLinesFitSide)
  {


    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];
    long SP_O = 0;
        for (int i = 0; i < 20; i++)
        {
            HOperatorSet.GenEmptyObj(out OTemp[i]);
        }
    // Local iconic variables 

    HObject ho_SelectedRegionsS, ho_BatteryNoTabRegionsOut;
    HObject ho_BatteryNoTabRegionsRect, ho_sliceRectRegions;
    HObject ho_sliceRectRegionsROI, ho_sliceRectRegionsROIRaw;
    HObject ho_sliceobjRectsssssssRemoved, ho_objNoTabRegionRect=null;
    HObject ho_sliceRectobjNoTabRegions=null, ho_sliceobjRectRemoved=null;
    HObject ho_RegionLinesFit, ho_sliceRectRegionsROISide, ho_ContoursliceRectRegionsROI;


    // Local control variables 

    HTuple hv_Row1RectOut, hv_Col1RectOut, hv_Row2RectOut;
    HTuple hv_Col2RectOut, hv_Row1BatteryNoTab, hv_Col1BatteryNoTab;
    HTuple hv_Row2BatteryNoTab, hv_Col2BatteryNoTab, hv_lengthOfNoTabRegion;
    HTuple hv_numberOfNoTabRegion, hv_subindex, hv_totalLen;
    HTuple hv_stepOflen, hv_sliceRectRow1, hv_sliceRectRow2;
    HTuple hv_sliceRectCol1, hv_sliceRectCol2, hv_sliceIndexGap;
    HTuple hv_countOfleftTop=new HTuple(), hv_sliceIndex=new HTuple();
    HTuple hv_Row1sliceRect, hv_Col1sliceRect, hv_Row2sliceRect;
    HTuple hv_Col2sliceRect, hv_Row1SLobjNoTab=new HTuple();
    HTuple hv_Col1SLobjNoTab=new HTuple(), hv_Row2SLobjNoTab=new HTuple();
    HTuple hv_Col2SLobjNoTab=new HTuple(), hv_lenofRow1SLobjNoTab=new HTuple();
    HTuple hv_Row1SLobjNoTabPLine=new HTuple(), hv_Row1SLobjNoTabPLIndex=new HTuple();
    HTuple hv_Values, hv_isideTab, hv_len, hv_y, hv_x, hv_xxxx;
    HTuple hv_idxxxx, hv_xtx, hv_xty, hv_invxtx, hv_beta, hv_Valueside;
    HTuple hv_towPointsRow, hv_Newy, hv_RowBegin, hv_ColBegin;
    HTuple hv_RowEnd, hv_ColEnd, hv_Nr, hv_Nc, hv_Dist;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFitSide);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsS);
    HOperatorSet.GenEmptyObj(out ho_BatteryNoTabRegionsOut);
    HOperatorSet.GenEmptyObj(out ho_BatteryNoTabRegionsRect);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegions);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROI);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROIRaw);
    HOperatorSet.GenEmptyObj(out ho_sliceobjRectsssssssRemoved);
    HOperatorSet.GenEmptyObj(out ho_objNoTabRegionRect);
    HOperatorSet.GenEmptyObj(out ho_sliceRectobjNoTabRegions);
    HOperatorSet.GenEmptyObj(out ho_sliceobjRectRemoved);
    HOperatorSet.GenEmptyObj(out ho_RegionLinesFit);
    HOperatorSet.GenEmptyObj(out ho_sliceRectRegionsROISide);
    HOperatorSet.GenEmptyObj(out ho_ContoursliceRectRegionsROI);

    try
    {
      ho_SelectedRegionsS.Dispose();
      HOperatorSet.CopyObj(ho_BatteryNoTabRegions, out ho_SelectedRegionsS, 1, -1);
      //10.拟合底部直线进行拟合直线前的准备
      //剔除左边侧封区域
      //剔除每个区域的边缘
      //剔除区域内的最高点14%（当采样数量大于15时）
      ho_RegionLinesFitSide.Dispose();
      HOperatorSet.GenEmptyObj(out ho_RegionLinesFitSide);
      //shape_trans (BatteryNoTabRegionsOut, BatteryNoTabRegionsOut, 'convex')
      HOperatorSet.SmallestRectangle1(ho_SelectedRegionsS, out hv_Row1RectOut, out hv_Col1RectOut, 
          out hv_Row2RectOut, out hv_Col2RectOut);
      ho_BatteryNoTabRegionsOut.Dispose();
      HOperatorSet.SortRegion(ho_SelectedRegionsS, out ho_BatteryNoTabRegionsOut, 
          "upper_left", "true", "column");
      HOperatorSet.SmallestRectangle1(ho_BatteryNoTabRegionsOut, out hv_Row1BatteryNoTab, 
          out hv_Col1BatteryNoTab, out hv_Row2BatteryNoTab, out hv_Col2BatteryNoTab);
      ho_BatteryNoTabRegionsRect.Dispose();
      HOperatorSet.GenRectangle1(out ho_BatteryNoTabRegionsRect, hv_Row1BatteryNoTab, 
          hv_Col1BatteryNoTab, hv_Row2BatteryNoTab, hv_Col2BatteryNoTab);
      OTemp[SP_O] = ho_BatteryNoTabRegionsRect.CopyObj(1,-1);
      SP_O++;
      ho_BatteryNoTabRegionsRect.Dispose();
      HOperatorSet.Connection(OTemp[SP_O-1], out ho_BatteryNoTabRegionsRect);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      hv_lengthOfNoTabRegion = hv_Row2BatteryNoTab-hv_Row1BatteryNoTab;
      hv_numberOfNoTabRegion = new HTuple(hv_Row1BatteryNoTab.TupleLength());
      //剔除最上边的区域侧边封印区域
      if ((int)(new HTuple(((hv_lengthOfNoTabRegion.TupleSelect(0))).TupleGreater(
          160))) != 0)
      {
        hv_Row1BatteryNoTab[0] = (hv_Row1BatteryNoTab.TupleSelect(0))+10;
        hv_Row2BatteryNoTab[0] = (hv_Row2BatteryNoTab.TupleSelect(0))-10;
      }
      for (hv_subindex=1; hv_subindex.Continue(hv_numberOfNoTabRegion-1, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        if ((int)(new HTuple(((hv_lengthOfNoTabRegion.TupleSelect(hv_subindex))).TupleGreater(
            10))) != 0)
        {
          hv_Row1BatteryNoTab[hv_subindex] = (hv_Row1BatteryNoTab.TupleSelect(hv_subindex))+5;
          hv_Row2BatteryNoTab[hv_subindex] = (hv_Row2BatteryNoTab.TupleSelect(hv_subindex))-5;
        }
      }
      hv_lengthOfNoTabRegion = hv_Row2BatteryNoTab-hv_Row1BatteryNoTab;
      HOperatorSet.TupleSum(hv_lengthOfNoTabRegion, out hv_totalLen);
      hv_stepOflen = (hv_totalLen-200)/50;
      if ((int)(new HTuple(hv_stepOflen.TupleLess(2))) != 0)
      {
        hv_stepOflen = 2;
      }
      hv_sliceRectRow1 = new HTuple();
      hv_sliceRectRow2 = new HTuple();
      hv_sliceRectCol1 = new HTuple();
      hv_sliceRectCol2 = new HTuple();
      hv_sliceIndexGap = 0;
      for (hv_subindex=0; hv_subindex.Continue(hv_numberOfNoTabRegion-1, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        hv_countOfleftTop = (hv_lengthOfNoTabRegion.TupleSelect(hv_subindex))/hv_stepOflen;

        for (hv_sliceIndex=hv_sliceIndexGap; hv_sliceIndex.Continue(hv_sliceIndexGap+hv_countOfleftTop, 1); hv_sliceIndex = hv_sliceIndex.TupleAdd(1))
        {
          hv_sliceRectRow1[hv_sliceIndex] = (hv_Row1BatteryNoTab.TupleSelect(hv_subindex))+((hv_sliceIndex-hv_sliceIndexGap)*hv_stepOflen);
          hv_sliceRectRow2[hv_sliceIndex] = (hv_Row1BatteryNoTab.TupleSelect(hv_subindex))+((hv_sliceIndex-hv_sliceIndexGap)*hv_stepOflen);
          hv_sliceRectCol1[hv_sliceIndex] = (hv_Col2BatteryNoTab.TupleSelect(hv_subindex))-30;
          hv_sliceRectCol2[hv_sliceIndex] = (hv_Col2BatteryNoTab.TupleSelect(hv_subindex))+30;
        }

        hv_sliceIndexGap = hv_sliceIndexGap+hv_countOfleftTop;

      }


      ho_sliceRectRegions.Dispose();
      HOperatorSet.GenRectangle1(out ho_sliceRectRegions, hv_sliceRectRow1, hv_sliceRectCol1, 
          hv_sliceRectRow2, hv_sliceRectCol2);
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Intersection(ho_sliceRectRegions, ho_BatteryNoTabRegionsOut, out ho_sliceRectRegionsROI
          );
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.ClosingRectangle1(OTemp[SP_O-1], out ho_sliceRectRegionsROI, 1, 
          60);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Union1(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.FillUp(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Connection(OTemp[SP_O-1], out ho_sliceRectRegionsROI);
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.SortRegion(OTemp[SP_O-1], out ho_sliceRectRegionsROI, "upper_left", 
          "true", "row");
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      HOperatorSet.SmallestRectangle1(ho_sliceRectRegionsROI, out hv_Row1sliceRect, 
          out hv_Col1sliceRect, out hv_Row2sliceRect, out hv_Col2sliceRect);
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.GenRectangle1(out ho_sliceRectRegionsROI, hv_Row2sliceRect, hv_Col1sliceRect, 
          hv_Row2sliceRect, hv_Col2sliceRect);
      ho_sliceRectRegionsROIRaw.Dispose();
      HOperatorSet.Connection(ho_sliceRectRegionsROI, out ho_sliceRectRegionsROIRaw
          );


      //如果同一区域超出15个点,剔除最靠近上方的5个点
      ho_sliceobjRectsssssssRemoved.Dispose();
      HOperatorSet.GenEmptyObj(out ho_sliceobjRectsssssssRemoved);
      for (hv_subindex=1; hv_subindex.Continue(hv_numberOfNoTabRegion, 1); hv_subindex = hv_subindex.TupleAdd(1))
      {
        ho_objNoTabRegionRect.Dispose();
        HOperatorSet.SelectObj(ho_BatteryNoTabRegionsRect, out ho_objNoTabRegionRect, 
            hv_subindex);
        ho_sliceRectobjNoTabRegions.Dispose();
        HOperatorSet.Intersection(ho_objNoTabRegionRect, ho_sliceRectRegionsROIRaw, 
            out ho_sliceRectobjNoTabRegions);
        OTemp[SP_O] = ho_sliceRectobjNoTabRegions.CopyObj(1,-1);
        SP_O++;
        ho_sliceRectobjNoTabRegions.Dispose();
        HOperatorSet.Connection(OTemp[SP_O-1], out ho_sliceRectobjNoTabRegions);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        HOperatorSet.SmallestRectangle1(ho_sliceRectobjNoTabRegions, out hv_Row1SLobjNoTab, 
            out hv_Col1SLobjNoTab, out hv_Row2SLobjNoTab, out hv_Col2SLobjNoTab);
        hv_lenofRow1SLobjNoTab = new HTuple(hv_Row1SLobjNoTab.TupleLength());
        if ((int)(new HTuple(hv_lenofRow1SLobjNoTab.TupleGreater(15))) != 0)
        {
          HOperatorSet.TupleSortIndex(hv_Row1SLobjNoTab, out hv_Row1SLobjNoTabPLine);
          HOperatorSet.TupleSelectRange(hv_Row1SLobjNoTabPLine, 0, (hv_lenofRow1SLobjNoTab/7)-1, 
              out hv_Row1SLobjNoTabPLine);
          hv_Row1SLobjNoTabPLIndex = hv_Row1SLobjNoTabPLine+1;
          ho_sliceobjRectRemoved.Dispose();
          HOperatorSet.SelectObj(ho_sliceRectobjNoTabRegions, out ho_sliceobjRectRemoved, 
              hv_Row1SLobjNoTabPLIndex);
          OTemp[SP_O] = ho_sliceobjRectsssssssRemoved.CopyObj(1,-1);
          SP_O++;
          ho_sliceobjRectsssssssRemoved.Dispose();
          HOperatorSet.ConcatObj(OTemp[SP_O-1], ho_sliceobjRectRemoved, out ho_sliceobjRectsssssssRemoved
              );
          OTemp[SP_O-1].Dispose();
          SP_O = 0;
        }
      }
      OTemp[SP_O] = ho_sliceRectRegionsROI.CopyObj(1,-1);
      SP_O++;
      ho_sliceRectRegionsROI.Dispose();
      HOperatorSet.Difference(OTemp[SP_O-1], ho_sliceobjRectsssssssRemoved, out ho_sliceRectRegionsROI
          );
      OTemp[SP_O-1].Dispose();
      SP_O = 0;



      //11.以tab为界限,分别拟合直线?不行，如果相差比较远会得到很奇怪的拟合线
      ho_RegionLinesFit.Dispose();
      HOperatorSet.GenEmptyObj(out ho_RegionLinesFit);
      hv_Values = new HTuple();
      hv_Values[0] = 0;
      hv_Values[1] = 0;
      hv_Values[2] = 0;
      hv_Values[3] = 0;
      hv_isideTab = 2;
      //* for isideTab := 0 to 1 by 1
      //gen_empty_obj (sliceRectRegionsROISide)
      //if (isideTab=0)
        //concat_obj (sliceRectRegionsROISide, defineInnerRectsLeft, sliceRectRegionsROISide)
      //elseif (isideTab=1)
        //concat_obj (sliceRectRegionsROISide, defineInnerRectsRight, sliceRectRegionsROISide)
      //else
        //concat_obj (sliceRectRegionsROISide, defineInnerRects, sliceRectRegionsROISide)
      //endif
      //intersection (sliceRectRegionsROI, sliceRectRegionsROISide, sliceRectRegionsROISide)
      ho_sliceRectRegionsROISide.Dispose();
      HOperatorSet.SortRegion(ho_sliceRectRegionsROI, out ho_sliceRectRegionsROISide, 
          "upper_left", "true", "row");
      HOperatorSet.SmallestRectangle1(ho_sliceRectRegionsROISide, out hv_Row1sliceRect, 
          out hv_Col1sliceRect, out hv_Row2sliceRect, out hv_Col2sliceRect);

      hv_len = new HTuple(hv_Col2sliceRect.TupleLength());
      HOperatorSet.CreateMatrix(hv_len, 1, hv_Col2sliceRect, out hv_y);
      HOperatorSet.CreateMatrix(hv_len, 2, 1, out hv_x);
      hv_xxxx = new HTuple();
      for (hv_idxxxx=0; hv_idxxxx.Continue(hv_len-1, 1); hv_idxxxx = hv_idxxxx.TupleAdd(1))
      {
        hv_xxxx[hv_idxxxx] = hv_idxxxx;
      }
      HOperatorSet.SetValueMatrix(hv_x, hv_xxxx, HTuple.TupleGenConst(hv_len,0), 
          hv_Row2sliceRect);

      HOperatorSet.MultMatrix(hv_x, hv_x, "ATB", out hv_xtx);
      HOperatorSet.MultMatrix(hv_x, hv_y, "ATB", out hv_xty);

      HOperatorSet.InvertMatrix(hv_xtx, "general", 0, out hv_invxtx);
      HOperatorSet.MultMatrix(hv_invxtx, hv_xty, "AB", out hv_beta);
      HOperatorSet.GetFullMatrix(hv_beta, out hv_Valueside);

      hv_Values[(hv_isideTab*2)+0] = hv_Valueside.TupleSelect(0);
      hv_Values[(hv_isideTab*2)+1] = hv_Valueside.TupleSelect(1);
      hv_towPointsRow = new HTuple();
      hv_towPointsRow = hv_towPointsRow.TupleConcat(hv_Row2RectOut-((hv_Row2RectOut-hv_Row1RectOut)*0.6));
      hv_towPointsRow = hv_towPointsRow.TupleConcat(hv_Row2RectOut);
      //if (isideTab=0)
        //towPointsCol := [300,Col1Tab[1]]
      //elseif (isideTab=1)
        //towPointsCol := [Col2Tab[0],Col2Tab[1]+700]
      //else
        //isideTab := 0
        //Values[isideTab*2+0] := Valueside[0]
        //Values[isideTab*2+1] := Valueside[1]
        //towPointsCol := [300,Col2Tab[1]+700]
      //endif

      hv_Newy = ((hv_Values.TupleSelect((hv_isideTab*2)+0))*hv_towPointsRow)+(hv_Values.TupleSelect(
          (hv_isideTab*2)+1));

      ho_ContoursliceRectRegionsROI.Dispose();
      HOperatorSet.GenContourPolygonXld(out ho_ContoursliceRectRegionsROI, hv_towPointsRow, 
          hv_Newy);
      HOperatorSet.FitLineContourXld(ho_ContoursliceRectRegionsROI, "gauss", -1, 
          0, 5, 1, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, 
          out hv_Nr, out hv_Nc, out hv_Dist);
      ho_RegionLinesFitSide.Dispose();
      HOperatorSet.GenRegionLine(out ho_RegionLinesFitSide, hv_RowBegin, hv_ColBegin, 
          hv_RowEnd, hv_ColEnd);
      ho_SelectedRegionsS.Dispose();
      ho_BatteryNoTabRegionsOut.Dispose();
      ho_BatteryNoTabRegionsRect.Dispose();
      ho_sliceRectRegions.Dispose();
      ho_sliceRectRegionsROI.Dispose();
      ho_sliceRectRegionsROIRaw.Dispose();
      ho_sliceobjRectsssssssRemoved.Dispose();
      ho_objNoTabRegionRect.Dispose();
      ho_sliceRectobjNoTabRegions.Dispose();
      ho_sliceobjRectRemoved.Dispose();
      ho_RegionLinesFit.Dispose();
      ho_sliceRectRegionsROISide.Dispose();
      ho_ContoursliceRectRegionsROI.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_SelectedRegionsS.Dispose();
      ho_BatteryNoTabRegionsOut.Dispose();
      ho_BatteryNoTabRegionsRect.Dispose();
      ho_sliceRectRegions.Dispose();
      ho_sliceRectRegionsROI.Dispose();
      ho_sliceRectRegionsROIRaw.Dispose();
      ho_sliceobjRectsssssssRemoved.Dispose();
      ho_objNoTabRegionRect.Dispose();
      ho_sliceRectobjNoTabRegions.Dispose();
      ho_sliceobjRectRemoved.Dispose();
      ho_RegionLinesFit.Dispose();
      ho_sliceRectRegionsROISide.Dispose();
      ho_ContoursliceRectRegionsROI.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            throw HDevExpDefaultException;
    }
  }

  public void rotateaxis_rectangle2 (HObject ho_rect2Ori, out HObject ho_rect2Rotated, 
      HTuple hv_row_center, HTuple hv_col_center, HTuple hv_axis_phi, HTuple hv_axisdegreeOffset)
  {



    // Local iconic variables 

    HObject ho_Circle_BR;


    // Local control variables 

    HTuple hv_Row11LinesFit, hv_Column11LinesFit;
    HTuple hv_Row21LinesFit, hv_Column21LinesFit, hv_RowLinesFit;
    HTuple hv_ColLinesFit, hv_PhiLinesFit, hv_len1LinesFit;
    HTuple hv_len2LinesFit, hv_dBRx, hv_dBRy, hv_dBRs, hv_rBR;
    HTuple hv_ThetaBR, hv_AlphaBR, hv_dBRx2, hv_dBRy2, hv_Sgn_xBR;
    HTuple hv_Sgn_yBR, hv_x_BR, hv_y_BR;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_rect2Rotated);
    HOperatorSet.GenEmptyObj(out ho_Circle_BR);

    try
    {

      ho_rect2Rotated.Dispose();
      HOperatorSet.GenEmptyObj(out ho_rect2Rotated);



      HOperatorSet.SmallestRectangle1(ho_rect2Ori, out hv_Row11LinesFit, out hv_Column11LinesFit, 
          out hv_Row21LinesFit, out hv_Column21LinesFit);
      HOperatorSet.SmallestRectangle2(ho_rect2Ori, out hv_RowLinesFit, out hv_ColLinesFit, 
          out hv_PhiLinesFit, out hv_len1LinesFit, out hv_len2LinesFit);


      hv_dBRx = hv_RowLinesFit-hv_row_center;
      hv_dBRy = hv_ColLinesFit-hv_col_center;
      hv_dBRs = (hv_dBRx*hv_dBRx)+(hv_dBRy*hv_dBRy);
      //distance to center
      HOperatorSet.TupleSqrt(hv_dBRs, out hv_rBR);
      HOperatorSet.TupleAtan2(hv_dBRy.TupleAbs(), hv_dBRx.TupleAbs(), out hv_ThetaBR);
      //recover center before rotation
      hv_AlphaBR = hv_axis_phi.Clone();
      if ((int)(new HTuple(((hv_dBRy*hv_dBRx)).TupleLess(0))) != 0)
      {
        hv_AlphaBR = -hv_axis_phi;
      }

      hv_dBRx2 = hv_rBR*((((hv_ThetaBR+hv_AlphaBR)+hv_axisdegreeOffset)).TupleCos()
          );
      hv_dBRy2 = hv_rBR*((((hv_ThetaBR+hv_AlphaBR)+hv_axisdegreeOffset)).TupleSin()
          );

      HOperatorSet.TupleSgn((hv_dBRx*1.0)/hv_rBR, out hv_Sgn_xBR);
      HOperatorSet.TupleSgn((hv_dBRy*1.0)/hv_rBR, out hv_Sgn_yBR);

      hv_x_BR = hv_row_center+(hv_dBRx2*hv_Sgn_xBR);
      hv_y_BR = hv_col_center+(hv_dBRy2*hv_Sgn_yBR);

      ho_Circle_BR.Dispose();
      HOperatorSet.GenCircle(out ho_Circle_BR, hv_x_BR, hv_y_BR, 10);
      ho_rect2Rotated.Dispose();
      HOperatorSet.GenRectangle2(out ho_rect2Rotated, hv_x_BR, hv_y_BR, hv_PhiLinesFit+hv_axis_phi, 
          hv_len1LinesFit, hv_len2LinesFit);





      ho_Circle_BR.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Circle_BR.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void Tab_orientation_Insp (HObject ho_ImageRotateS, HObject ho_RectangleROI, 
      HTuple hv_owindowHandle, HTuple hv_m_maxgray_find_contour, HTuple hv_height_body, 
      HTuple hv_width_total, HTuple hv_m_possiblearea_2ndcol1, HTuple hv_m_possiblearea_2ndcol2, 
      HTuple hv_Blk_and_Wht, out HTuple hv_bResultTabOri, out HTuple hv_Column2, out HTuple hv_Row2)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];
        for (int i = 0; i < 20; i++)
        {
            HOperatorSet.GenEmptyObj(out OTemp[i]);
        }
    long SP_O = 0;

    // Local iconic variables 

    HObject ho_ImageReducedS2=null, ho_RegionS2=null;
    HObject ho_RegionFillUp=null, ho_ConnectedRegionsS=null;
    HObject ho_SelectedRegionsSAll=null, ho_Rectangle=null;
    HObject ho_ImageReduced=null, ho_SelectedRegions1=null;
    HObject ho_ConnectedRegions=null, ho_SelectedRegions=null;


    // Local control variables 

    HTuple hv_width_image=new HTuple(), hv_height_image=new HTuple();
    HTuple hv_Row1=new HTuple(), hv_Column1=new HTuple(), hv_Number=new HTuple();
    HTuple hv_Area=new HTuple(), hv_Row=new HTuple(), hv_Column=new HTuple();
    HTuple hv_Area_all=new HTuple(), hv_Area_ratio=new HTuple();
    HTuple hv_Number1=new HTuple(), hv_Exception;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageReducedS2);
    HOperatorSet.GenEmptyObj(out ho_RegionS2);
    HOperatorSet.GenEmptyObj(out ho_RegionFillUp);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegionsS);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegionsSAll);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);

    hv_bResultTabOri = new HTuple();
    hv_Column2 = new HTuple();
    hv_Row2 = new HTuple();
    try
    {
      try
      {
        //*************初始化输出参数bResultTabOri=1表示极耳方向错误
        hv_bResultTabOri = 0;


        HOperatorSet.GetImageSize(ho_ImageRotateS, out hv_width_image, out hv_height_image);
        HOperatorSet.DispImage(ho_ImageRotateS, hv_owindowHandle);
        //get workign region for the body
        ho_ImageReducedS2.Dispose();
        HOperatorSet.ReduceDomain(ho_ImageRotateS, ho_RectangleROI, out ho_ImageReducedS2
            );
        //emphasize (ImageReducedS2, ImageReducedS2, 10, 10, 2)
        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(1))) != 0)
        {
          //threshold (ImageReducedS2, RegionS2, 220, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS2, out ho_RegionS2, 220, 255);
        }
        else
        {
          //threshold (ImageReducedS2, RegionS2, 0, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReducedS2, out ho_RegionS2, 0, 80);

        }
        ho_RegionFillUp.Dispose();
        HOperatorSet.FillUp(ho_RegionS2, out ho_RegionFillUp);
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.Connection(ho_RegionFillUp, out ho_ConnectedRegionsS);
        OTemp[SP_O] = ho_ConnectedRegionsS.CopyObj(1,-1);
        SP_O++;
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.FillUp(OTemp[SP_O-1], out ho_ConnectedRegionsS);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        HOperatorSet.DispObj(ho_ConnectedRegionsS, hv_owindowHandle);
        //tuple_sqrt (height_body*height_body+width_total*width_total, Sqrt)
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegionsS, out ho_SelectedRegionsSAll, 
            ((new HTuple("area")).TupleConcat("height")).TupleConcat("width"), "and", 
            ((((((hv_height_body*hv_width_total)*2)/4)).TupleConcat(hv_height_body/2))).TupleConcat(
            hv_width_total/2), ((((hv_height_body*hv_width_image)).TupleConcat(hv_height_body*2.2))).TupleConcat(
            hv_width_image));
        //select_shape (SelectedRegionsSAll_0, SelectedRegionsSAll, ['column2'], 'and', [m_possiblearea_2ndcol1+1], [m_possiblearea_2ndcol2-1])
        OTemp[SP_O] = ho_SelectedRegionsSAll.CopyObj(1,-1);
        SP_O++;
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SortRegion(OTemp[SP_O-1], out ho_SelectedRegionsSAll, "lower_right", 
            "false", "column");
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
        OTemp[SP_O] = ho_SelectedRegionsSAll.CopyObj(1,-1);
        SP_O++;
        ho_SelectedRegionsSAll.Dispose();
        HOperatorSet.SelectObj(OTemp[SP_O-1], out ho_SelectedRegionsSAll, 1);
        OTemp[SP_O-1].Dispose();
        SP_O = 0;

        //**********去除叠料的影响******
        HOperatorSet.SmallestRectangle1(ho_SelectedRegionsSAll, out hv_Row1, out hv_Column1, 
            out hv_Row2, out hv_Column2);
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column2-(hv_width_total/3), 
            hv_Row2+20, hv_Column2+20);
        ho_ImageReduced.Dispose();
        HOperatorSet.ReduceDomain(ho_ImageRotateS, ho_Rectangle, out ho_ImageReduced
            );
        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(1))) != 0)
        {
          //threshold (ImageReduced, RegionS2, 220, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionS2, 220, 255);
        }
        else
        {
          //threshold (ImageReduced, RegionS2, 0, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionS2, 0, 80);
        }

        ho_RegionFillUp.Dispose();
        HOperatorSet.FillUp(ho_RegionS2, out ho_RegionFillUp);
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.Connection(ho_RegionFillUp, out ho_ConnectedRegionsS);
        ho_SelectedRegions1.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegionsS, out ho_SelectedRegions1, "height", 
            "and", (2*hv_height_body)/3, 2.2*hv_height_body);
        HOperatorSet.SmallestRectangle1(ho_SelectedRegions1, out hv_Row1, out hv_Column1, 
            out hv_Row2, out hv_Column2);
        //**********判断极耳方向******
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row2-120, hv_Column2-hv_width_total, 
            hv_Row2, hv_Column2);
        ho_ImageReduced.Dispose();
        HOperatorSet.ReduceDomain(ho_ImageRotateS, ho_Rectangle, out ho_ImageReduced
            );
        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(1))) != 0)
        {
          //threshold (ImageReduced, RegionS2, 220, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionS2, 220, 255);
        }
        else
        {
          //threshold (ImageReduced, RegionS2, 0, m_maxgray_find_contour)
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionS2, 0, 80);
        }

        ho_RegionFillUp.Dispose();
        HOperatorSet.FillUp(ho_RegionS2, out ho_RegionFillUp);
        ho_ConnectedRegionsS.Dispose();
        HOperatorSet.Connection(ho_RegionFillUp, out ho_ConnectedRegionsS);
        ho_SelectedRegions1.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegionsS, out ho_SelectedRegions1, "area", 
            "and", hv_width_total*20, 9999999);
        HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);

        if ((int)(new HTuple(hv_Number.TupleGreater(0))) != 0)
        {
          HOperatorSet.AreaCenter(ho_SelectedRegions1, out hv_Area, out hv_Row, out hv_Column);
          hv_Area_all = hv_width_total*120;
          hv_Area_ratio = (hv_Area*1.0)/hv_Area_all;
          if ((int)(new HTuple(hv_Area_ratio.TupleGreater(0.75))) != 0)
          {
          }
          else
          {
            hv_bResultTabOri = 1;
          }
        }
        else
        {
          hv_bResultTabOri = 1;
        }
        //***如果是黑色的，Tab会被打亮
        if ((int)(new HTuple(hv_Blk_and_Wht.TupleEqual(0))) != 0)
        {
          ho_Rectangle.Dispose();
          HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row2, hv_Column2-hv_width_total, 
              hv_Row2+120, hv_Column2);
          ho_ImageReduced.Dispose();
          HOperatorSet.ReduceDomain(ho_ImageRotateS, ho_Rectangle, out ho_ImageReduced
              );
          ho_RegionS2.Dispose();
          HOperatorSet.Threshold(ho_ImageReduced, out ho_RegionS2, 240, 255);
          ho_ConnectedRegions.Dispose();
          HOperatorSet.Connection(ho_RegionS2, out ho_ConnectedRegions);
          ho_SelectedRegions.Dispose();
          HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area", 
              "and", 1700, 9999);
          HOperatorSet.CountObj(ho_SelectedRegions, out hv_Number1);
          if ((int)(new HTuple(hv_Number1.TupleGreater(0))) != 0)
          {
            hv_bResultTabOri = 1;
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_bResultTabOri = 0;
      }
      ho_ImageReducedS2.Dispose();
      ho_RegionS2.Dispose();
      ho_RegionFillUp.Dispose();
      ho_ConnectedRegionsS.Dispose();
      ho_SelectedRegionsSAll.Dispose();
      ho_Rectangle.Dispose();
      ho_ImageReduced.Dispose();
      ho_SelectedRegions1.Dispose();
      ho_ConnectedRegions.Dispose();
      ho_SelectedRegions.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageReducedS2.Dispose();
      ho_RegionS2.Dispose();
      ho_RegionFillUp.Dispose();
      ho_ConnectedRegionsS.Dispose();
      ho_SelectedRegionsSAll.Dispose();
      ho_Rectangle.Dispose();
      ho_ImageReduced.Dispose();
      ho_SelectedRegions1.Dispose();
      ho_ConnectedRegions.Dispose();
      ho_SelectedRegions.Dispose();
            for (int i = 0; i < 20; i++)
            {
                OTemp[i].Dispose();
            }
            throw HDevExpDefaultException;
    }
  }

  public void Battery_Overlap_Insp (HObject ho_Image, HObject ho_SelectedRegionsS, 
      HTuple hv_height_body, HTuple hv_width_body, out HTuple hv_Phi)
  {



    // Local iconic variables 

    HObject ho_Rectangle=null, ho_ImageReduced=null;
    HObject ho_Edges=null, ho_SelectedContours=null;


    // Local control variables 

    HTuple hv_RowE1=new HTuple(), hv_ColE1=new HTuple();
    HTuple hv_RowE2=new HTuple(), hv_ColE2=new HTuple(), hv_RowBegin=new HTuple();
    HTuple hv_ColBegin=new HTuple(), hv_RowEnd=new HTuple();
    HTuple hv_ColEnd=new HTuple(), hv_Nr=new HTuple(), hv_Nc=new HTuple();
    HTuple hv_Dist=new HTuple(), hv_Exception;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_Edges);
    HOperatorSet.GenEmptyObj(out ho_SelectedContours);

    hv_Phi = new HTuple();
    try
    {
      try
      {
        HOperatorSet.SmallestRectangle1(ho_SelectedRegionsS, out hv_RowE1, out hv_ColE1, 
            out hv_RowE2, out hv_ColE2);
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, ((hv_RowE1+hv_RowE2)/2)-(hv_height_body/8), 
            hv_ColE2-(hv_width_body/3), ((hv_RowE1+hv_RowE2)/2)+(hv_height_body/8), 
            hv_ColE2+40);
        ho_ImageReduced.Dispose();
        HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced);
        ho_Edges.Dispose();
        HOperatorSet.EdgesSubPix(ho_ImageReduced, out ho_Edges, "canny", 5, 30, 100);
        ho_SelectedContours.Dispose();
        HOperatorSet.SelectContoursXld(ho_Edges, out ho_SelectedContours, "contour_length", 
            hv_height_body/5, hv_height_body/2, -0.5, 0.5);
        HOperatorSet.FitLineContourXld(ho_SelectedContours, "tukey", -1, 0, 5, 2, 
            out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, 
            out hv_Nc, out hv_Dist);
        hv_Phi = -((((hv_RowEnd-hv_RowBegin)/(hv_ColEnd-hv_ColBegin))).TupleAtan()
            );

      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      ho_Rectangle.Dispose();
      ho_ImageReduced.Dispose();
      ho_Edges.Dispose();
      ho_SelectedContours.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Rectangle.Dispose();
      ho_ImageReduced.Dispose();
      ho_Edges.Dispose();
      ho_SelectedContours.Dispose();

      throw HDevExpDefaultException;
    }
  }
    // Main procedure 
    public int action_parse_coordinate(Byte[] bmp, long width, long height, out double x, out double y, out double bx, out double by, out double a, string name)
    {
        x = 0.0;
        y = 0.0;
        a = 0.0;

        bx = 0.0;
        by = 0.0;
        int result = 1;
        IntPtr p_bmp = IntPtr.Zero;
        
        // Local iconic variables 

        HObject ho_DefectRegion=new HObject(), ho_Image=null, ho_Rectangle=null;
    HObject ho_RegionCenter=null;


    // Local control variables 

    HTuple hv__iErrorCode, hv_bFinalResultRet;
    HTuple hv_ImageFilesAll, hv_ImageFiles, hv_Index, hv_Width=new HTuple();
    HTuple hv_Height=new HTuple(), hv_WindowHandle=new HTuple();
    HTuple hv_Blk_and_Wht=new HTuple(), hv_delta_x=new HTuple();
    HTuple hv_delta_y=new HTuple(), hv_angle_out=new HTuple();
    HTuple hv_center_x=new HTuple(), hv_center_y=new HTuple();
    HTuple hv_phiRotated=new HTuple();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DefectRegion);
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_RegionCenter);

    try
    {
      //initialize variable
      hv__iErrorCode = 0;
      hv_bFinalResultRet = 0;

      ho_DefectRegion.Dispose();
      HOperatorSet.GenEmptyObj(out ho_DefectRegion);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      //Code generated by Image Acquisition 01 E:\JT\ST5\31A0B8\20171106\传输带定位
     // HOperatorSet.ListFiles("E:/上下料机视觉程序/上下料机视觉程序/入料定位算法/526468", 
       //   ((new HTuple("files")).TupleConcat("follow_links")).TupleConcat("recursive"), 
       //   out hv_ImageFilesAll);

      //list_files ('E:/上下料机视觉程序/上下料机视觉程序/入料定位算法/0819', ['files','follow_links','recursive'], ImageFilesAll)
      //list_files ('..\\0902\\', ['files','follow_links','recursive'], ImageFilesAll)


      //tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$','ignore_case'], ImageFiles)
     // HOperatorSet.TupleRegexpSelect(hv_ImageFilesAll, (new HTuple("\\d.(bmp|jpg|)$")).TupleConcat(
          //"ignore_case"), out hv_ImageFiles);
     // for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ImageFiles.TupleLength()
     //     ))-1); hv_Index = (int)hv_Index + 1)
    //  {
        //input_filename := ImageFiles[Index]
        //tuple_strrstr (ImageFiles[Index], '1.bmp', Position)
        //if (Position<1)
          //continue
        //endif

        ho_Image.Dispose();

            //Edit by ly ,便于从成品图片读取
            if (null == bmp)
            {
                HOperatorSet.ReadImage(out ho_Image, "D:\\test.jpg");
            }
            else
            {
                int size = bmp.Length;
                p_bmp = Marshal.AllocHGlobal(size);
                Marshal.Copy(bmp, 0, p_bmp, size);
                HOperatorSet.GenImage1Extern(out ho_Image, "byte", width, height, p_bmp, 0);
            }
            


                //HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(hv_Index));

        //parse_filename (input_filename, input_basename, input_ext, input_dir)
        //tuple_split (input_dir, '/', input_dirar)
        //inputdirLen := |input_dirar|
        //output_filename := 'D:/HQ1/result/'+input_dirar[inputdirLen-1]+'.bmp'


        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, 80, 180, hv_Height-80, hv_Width-250);
        dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //decompose3 (Image, ImageR, ImageG, ImageB)
        //************************************************************

        //***黑色和银色的区分（Blk_and_Wht=1表示银色；Blk_and_Wht=0表示黑色）

        hv_Blk_and_Wht = ATL_MC.Vision.Vision.batteryCFG.iBatteryColor;

        parse_coordinate_silver(ho_Image, hv_WindowHandle, hv_Blk_and_Wht, out hv_delta_x, 
            out hv_delta_y, out hv_angle_out, out hv_center_x, out hv_center_y,out result);


            x = hv_delta_x;
            y = hv_delta_y;
            a = hv_angle_out;

            bx = hv_center_x;
            by = hv_center_y;

            //add by ly 2019-11-13
            if((x==0) && (y==0) && (a==0))
            {

                result = 1;
            }

            if (HDevWindowStack.IsOpen())
        {
          //dev_display (Image)
        }
        ho_RegionCenter.Dispose();
        HOperatorSet.GenCircle(out ho_RegionCenter, hv_center_x, hv_center_y, 10);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_RegionCenter, HDevWindowStack.GetActive());
        }

        //gen_empty_obj (testImg)
        //get_image_size (testImg, aa, bb)

        hv_phiRotated = -1*hv_angle_out;
        //rotate_image (Image, ImageAdjAngle, phiRotated, 'nearest_neighbor')
        if (HDevWindowStack.IsOpen())
        {
          //dev_display (ImageAdjAngle)
        }

            if (HDevWindowStack.IsOpen())
            {
                if (0 < name.Length)
                {
                    HOperatorSet.DumpWindow(hv_WindowHandle, "jpeg", name);

                }
            }

            //dump_window (WindowHandle, 'bmp', output_filename)

            // if ((int)(new HTuple(hv_center_x.TupleLess(1))) != 0)
            // {
            //   HDevelopStop();
            //  }

            //  HDevelopStop();
            //}
            Marshal.FreeHGlobal(p_bmp);
        }
    catch (HalconException )
    {
      ho_DefectRegion.Dispose();
      ho_Image.Dispose();
      ho_Rectangle.Dispose();
      ho_RegionCenter.Dispose();
            Marshal.FreeHGlobal(p_bmp);

            result = 1;
    }
    ho_DefectRegion.Dispose();
    ho_Image.Dispose();
    ho_Rectangle.Dispose();
    ho_RegionCenter.Dispose();


        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }

        return result;

    }
}